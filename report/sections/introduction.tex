\section{Introduction}
\label{sec:introduction}

\subsection{Project Overview}
FeedApp is a small web app for running live polls. Users can create polls, vote, and discuss 
results, and the app updates everyone in real time so new votes and comments appear instantly. 
The goal is to make collecting and viewing feedback simple and fast.

The system has two main parts: a backend and a frontend. The backend provides REST endpoints for 
polls, votes, and comments, and emits events when data changes. The frontend displays the current state, 
listens for WebSocket updates, and stays synchronized with the server. The project also serves as a way to 
explore event-driven patterns and how they scale as more users interact with the system.

\subsection{Technology Stack Summary}
Backend: Java with Spring Boot and Spring Security for REST APIs, validation, and authentication. 
During development we use an in-memory H2 database, with Redis as a cache for frequently accessed poll data. Kafka handles domain events such as vote changes.

Frontend: React with TypeScript provides a simple, component-based UI that updates in real 
time through a single WebSocket connection.

Docker and CI: Docker Compose ensures consistent local deployment of all services, 
and GitHub Actions builds and tests the full stack on every push to maintain reliability.

We chose this stack because it is familiar, easy to set up, and scales horizontally. 
Kafka decouples writes from notifications, Redis improves read performance, and WebSockets keep the UI responsive

\subsection{Project Outcome}
The prototype supports creating polls, casting votes with instant updates, 
and adding threaded comments. We also compared Kafka and RabbitMQ as messaging 
systems for the event stream. In our experiments, Kafka outperformed RabbitMQ in 
both throughput and latency, remaining stable even under heavy write and fan-out 
load. RabbitMQ was simpler to work with but showed higher and more variable latency 
across all workloads. Using one topic per poll kept Kafka events organized, and Redis 
reduced repeated work on popular polls. The entire system is containerized so the full 
stack can be started with a single command.

\subsection{Report Organization}
This report is organized as follows. Section~\ref{sec:design} 
explains the design: main use cases, the domain model, and the overall 
architecture. Section~\ref{sec:technology} introduces Kafka (and the supporting tech), 
and outlines our experiment plan and assumptions. Section~\ref{sec:implementation} 
describes how we built the prototype, how services talk to each other, and how to run 
it locally. Finally, Section~\ref{sec:conclusion} sums up what we learned and lists 
possible next steps.
\medskip
