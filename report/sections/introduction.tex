\section{Introduction}
\label{sec:introduction}

\subsection{Project Overview}
FeedApp is a small web app for running live polls. Users can create polls, vote, and discuss 
results, and the app updates everyone in real time so new votes and comments appear instantly. 
The goal is to make collecting and viewing feedback simple and fast.

The system has two main parts: a backend and a frontend. The backend provides REST endpoints for 
polls, votes, and comments, and publishes events when data changes. The frontend displays the current state, 
listens for WebSocket updates, and stays synchronized with the server. The project also serves as a way to 
explore event-driven patterns and how they scale as more users interact with the system.

\subsection{Technology Stack Summary}
Backend: Java with Spring Boot and Spring Security is used to build REST APIs, check 
inputs, and handle login. During development we use an in-memory H2 database, and Redis 
stores fast-access poll data. Kafka is used to send events when something changes, 
like a vote.

Frontend: React with TypeScript gives a simple, component-based user interface that 
updates in real time through one WebSocket connection.

Docker and CI: Docker Compose makes sure all services run the same way locally, and 
GitHub Actions builds and tests the whole system on each push to keep everything stable.

We chose this stack because it is familiar, easy to set up, and can scale horizontally. 
Kafka separates updates from notifications, Redis makes reads faster, and WebSockets 
keep the UI fast and reactive.

\subsection{Project Outcome}
We delivered a working end-to-end prototype: users create polls, vote with instant updates, 
and add threaded comments while all clients stay in sync through Kafka events, Redis caching, 
and WebSocket notifications. The codebase includes authentication, core REST endpoints, and containerized startup. 
It provides a clear baseline for the technology evaluation and sets up for possible future implementations.

\subsection{Report Organization}
This report is organized as follows. Section~\ref{sec:design} 
explains the design: main use cases, the domain model, and the overall 
architecture. Section~\ref{sec:technology} introduces Kafka, 
and outlines our experiment plan and assumptions. Section~\ref{sec:implementation} 
gives a short view of how the prototype works: how to run it, how the backend processes changes, 
how events reach clients, and what can be extended. Finally, 
Section~\ref{sec:conclusion} sums up what we learned from building 
the app and comparing Kafka and RabbitMQ for real-time updates.
\medskip
