\section{Introduction}
\label{sec:introduction}

\subsection{Project Overview}
FeedApp is a small web app for running live polls. Users can create polls, vote, and discuss 
results, and the app updates everyone in real time so new votes and comments appear instantly. 
The goal is to make collecting and viewing feedback simple and fast.

The system has two main parts: a backend and a frontend. The backend provides REST endpoints for 
polls, votes, and comments, and emits events when data changes. The frontend displays the current state, 
listens for WebSocket updates, and stays synchronized with the server. The project also serves as a way to 
explore event-driven patterns and how they scale as more users interact with the system.

\subsection{Technology Stack Summary}
Backend: Java with Spring Boot and Spring Security for REST APIs, validation, and authentication. 
During development we use an in-memory H2 database, with Redis as a cache for frequently accessed poll data. Kafka handles domain events such as vote changes.

Frontend: React with TypeScript provides a simple, component-based UI that updates in real 
time through a single WebSocket connection.

Docker and CI: Docker Compose ensures consistent local deployment of all services, 
and GitHub Actions builds and tests the full stack on every push to maintain reliability.

We chose this stack because it is familiar, easy to set up, and scales horizontally. 
Kafka decouples writes from notifications, Redis improves read performance, and WebSockets keep the UI responsive

\subsection{Project Outcome}
We delivered a working end-to-end prototype: users create polls, vote with instant updates, 
and add threaded comments while all clients stay in sync through Kafka events, Redis caching, 
and WebSocket notifications. The codebase includes authentication, core REST endpoints, and containerized startup. 
It provides a clear baseline for the technology evaluation and sets up for possible future implementations.

\subsection{Report Organization}
This report is organized as follows. Section~\ref{sec:design} 
explains the design: main use cases, the domain model, and the overall 
architecture. Section~\ref{sec:technology} introduces Kafka (and the supporting tech), 
and outlines our experiment plan and assumptions. Section~\ref{sec:implementation} 
describes how we built the prototype, how services talk to each other, and how to run 
it locally. Finally, Section~\ref{sec:conclusion} sums up what we learned and lists 
possible next steps.
\medskip
