\section{Design}
\label{sec:design}

This section presents the design of the FeedApp system. It covers the main
functional use cases, the domain model that structures the application's core
entities and the overall software architecture. Together, these elements show
how the system supports real-time behavior, modular business logic and scalability. 
Each part is accompanied by a diagram to provide a high-level structural overview.

\subsection{Use Cases}

FeedApp allows users to vote on and discuss polls in real time. The system distinguishes between 
two user roles. \textbf{Anonymous users} can browse public polls, vote on them, register a new account and log in. 
\textbf{Registered users} have all anonymous permissions and can additionally create polls, comment on polls, 
vote on private polls if invited and manage polls they have created.


The following use cases emerge for these roles (as illustrated in Figure~\ref{fig:usecase}):

\begin{itemize}
  \item \textbf{Register and log in:} An anonymous user may register by providing a username, 
  email and password. Upon successful registration, the system issues a JWT token which is used 
  for stateless authentication. A registered user can log in at any time to obtain a new token.
  \item \textbf{Create Poll:} Registered users can create a poll by specifying a question, a set 
  of options and visibility (public or private). When a poll is created, it is persisted to the 
  database, a Kafka topic is created and a WebSocket update is broadcast to notify connected clients.
  \item \textbf{Vote on Poll:} Both anonymous and registered users may vote on public polls. 
  Private polls are restricted to invited registered users. Voting triggers several actions: 
  updating the database, publishing a \texttt{voteChange} event to Kafka, invalidating the 
  relevant Redis cache entry and broadcasting a WebSocket signal so that all clients refresh 
  their displayed results.
  \item \textbf{Comment:} Registered users may write comments on polls and reply to existing comments.
  \item \textbf{Manage Polls:} Poll creators may add extra options or delete their own polls. 
  Deletions cascade appropriately, removing options, votes and comments associated with the poll.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{figs/design/use_case.png}
	\caption{Use Case Diagram }
	\label{fig:usecase}
\end{figure}


\subsection{Domain Model}

The domain model captures the core business concepts of FeedApp and describes how polls, users, 
votes and comments relate to each other. These entities are implemented as JPA \texttt{@Entity} 
classes in the Spring Boot backend and persisted using Hibernate.

\paragraph*{User}
The \texttt{User} entity represents a registered account with a unique identifier, username,
email address and password hash. A user may create multiple polls, and vote and comment on polls.
In the case of anonymous voting, the \texttt{Vote} entity stores no user reference, 
making the user-vote relationship optional.

\paragraph*{Poll}
The \texttt{Poll} entity represents a question created by a user. It contains metadata such as 
visibility (public or private), validity period and a collection of vote options and comments. 
A \texttt{Poll} must have two or more \texttt{VoteOptions} and \textit{can} have many \texttt{Comments}.

\paragraph*{Vote}
The \texttt{Vote} entity represents an individual vote cast on a specific \texttt{VoteOption}. Votes
reference both the associated \texttt{VoteOption} and the (optional) user who cast the vote.

\paragraph*{VoteOption}
A poll must have at least two \texttt{VoteOptions} and each option is uniquely identified by its 
\texttt{pollID}. A \texttt{VoteOption} may receive many \texttt{Votes}.

\paragraph*{Comment}
The \texttt{Comment} entity represents comments written by a user connected to a \texttt{Poll}. Comments 
support nested replies through a recursive \texttt{parent} relationship. Comments are deleted if their parent or poll is 
removed.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{figs/design/domain_model.png}
	\caption{Domain Model Overview.}
	\label{fig:domainmodel}
\end{figure}



\subsection{Architecture}

The architecture of FeedApp follows a layered and event-driven design. The system is divided into 
a React/TypeScript frontend, a Spring Boot backend and supporting infrastructure services (H2, 
Redis, Kafka) orchestrated using Docker Compose. The design ensures clear separation, maintains 
responsiveness and enables horizontal scalability. Figure~\ref{fig:architecture} shows an 
overview of the main components.

\paragraph*{Frontend (React + TypeScript)}    
The user interface of the application. It communicates with the backend using REST API calls for 
CRUD operations and a persistent WebSocket connection for real-time updates. The frontend never 
accesses data directly. The UI listens for events such as \texttt{pollsUpdated} or 
\texttt{commentsUpdated} and refreshes data automatically.

\paragraph*{Backend (Spring Boot)}    
The backend implements the core application logic. The controllers map HTTP endpoints to methods in 
the service layer. The service layer contains domain logic for polls, votes, comments and events. 
This includes caching, authentication and Kafka integration. The persistence layer uses JPA/Hibernate 
to store and retrieve entities from the database. The backend also hosts the WebSocket endpoint 
(\texttt{/rawws}), used to notify clients of changes and applies stateless JWT-based authentication 
for all protected routes.

\paragraph*{Infrastructure Layer}
Several external components support performance, scalability and reliability. The H2 database is a 
lightweight SQL database used for storing users, polls, options, votes and comments during development.
The Redis Cache stores precomputed poll results to reduce the database load. Cache entries are invalidated 
when related Kafka events are consumed. Kafka clusters are used as a distributed event log for publishing 
vote events. It decouples producers and consumers and enables potential future scaling of services.

\paragraph*{Docker}
FeedApp is containerized using Docker to ensure that every component runs in a consistent and reproducible environment. 
Each service (frontend, backend, Redis, Kafka) runs in its own container, isolating dependencies and avoiding machine-
specific configuration issues. Docker Compose allows the entire system to be started with a single command.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{figs/design/sys_arc.png}
  \caption{System Architecture}
  \label{fig:architecture}
\end{figure}

The FeedApp design uses a combination of layered backend logic and event-driven infrastructure. Redis improves 
read performance, Kafka ensures decoupled communication and future extensibility and WebSockets provide responsive 
updates. Running the system inside Docker containers ensures that all components behave consistently across environments. 
Together, these choices result in a modular, scalable and maintainable architecture, suited for demonstrating modern 
distributed system principles.