\section{Prototype Implementation}
\label{sec:implementation}

This section gives a short overview of how the prototype is put together and how others can run and extend it. 

\subsection{Setup and Deployment}
Services: Spring Boot backend, React (Vite) frontend, Redis, and Kafka. All run with Docker Compose.

How to run
\begin{itemize}
  \item \texttt{docker compose up -d}
  \item Frontend: \texttt{http://localhost:5173}
  \item Backend: \texttt{http://localhost:8080}
\end{itemize}

Compose 
\begin{lstlisting}[language=yaml]
backend:
  ports: ["8080:8080"]
  environment:
    - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:29092
    - SPRING_REDIS_HOST=redis
frontend: { ports: ["5173:5173"], depends_on: [backend] }
\end{lstlisting}

\subsection{Backend Implementation}
Layering: Controllers map HTTP to Service methods; Services hold domain logic; 
Repositories persist entities. 
Small events are pushed to clients over a raw WebSocket to keep UIs in sync.

Controller example (vote)
\begin{lstlisting}[language=Java]
// PollController (excerpt)
@PostMapping("/{id}/vote")
public boolean castVote(@PathVariable Integer id,
                        @RequestParam Integer presentationOrder,
                        @AuthenticationPrincipal User user) {
  return pollService.castVote(id, user == null ? Optional.empty() : Optional.of(user.getUserId()),
                              presentationOrder);
}
\end{lstlisting}

Notify clients after changes
\begin{lstlisting}[language=Java]
// on create/update/delete
RawWebSocketServer.broadcast("pollsUpdated");
\end{lstlisting}


\subsection{Frontend Implementation}
The React app fetches data via REST and listens to a single WebSocket for deltas (new polls, comments, votes).

WebSocket client
\begin{lstlisting}[language=TypeScript]
// ws.ts
export const onWs = (f:(e:unknown)=>void) => (listeners.add(f), () => listeners.delete(f));
export function connectWs() {
  const u = `${location.protocol==="https:"?"wss":"ws"}://${location.hostname}:8080/rawws`;
  const ws = new WebSocket(u);
  ws.onmessage = ev => { try { emit(JSON.parse(ev.data)); } catch { emit(ev.data); } };
}
\end{lstlisting}

Integrating updates (App)
\begin{lstlisting}[language=TypeScript]
// App.tsx
useEffect(() => onWs(m => {
  if (m === "pollsUpdated") refreshPolls();
  if (m === "commentsUpdated") bumpCommentsVersion(activePollId);
}), []);
\end{lstlisting}

Calling the API (vote)
\begin{lstlisting}[language=TypeScript]
await fetch(`/api/polls/${id}/vote?presentationOrder=${order}`, { method: "POST" });
\end{lstlisting}

\subsection{Security}
Stateless JWT protects write operations; selected GET routes are public; CORS allows localhost during development.

\begin{lstlisting}[language=Java]
// SecurityConfig (rules excerpt)
http.csrf(AbstractHttpConfigurer::disable)
    .sessionManagement(s -> s.sessionCreationPolicy(STATELESS))
    .authorizeHttpRequests(a -> a
      .requestMatchers("/api/auth/**", "/rawws").permitAll()
      .requestMatchers(HttpMethod.GET, "/api/polls/**").permitAll()
      .requestMatchers(HttpMethod.POST, "/api/polls/*/vote").permitAll()
      .anyRequest().authenticated());
\end{lstlisting}

