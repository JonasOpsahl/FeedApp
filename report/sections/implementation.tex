\section{Prototype Implementation}
\label{sec:implementation}

This section outlines how the FeedApp prototype is implemented and demonstrates the core 
mechanisms behind running and extending the system. Only key code snippets are included here to illustrate the 
most important architectural details in our FeedApp.

\subsection{Setup and Deployment}

FeedApp runs as a multi-container application using Docker Compose, consisting of a Spring Boot backend, 
a React/Vite frontend, Redis for caching, and Kafka as the event bus. Infrastructure configuration is passed 
to the backend through environment variables. The most important part of the Compose file is shown below:

\begin{lstlisting}[language=yaml]
backend:
  ports: ["8080:8080"]
  environment:
    - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka-1:29092,kafka-2:29092,kafka-3:29092
    - SPRING_REDIS_HOST=redis

frontend:
  ports: ["5173:5173"]
  depends_on: [backend]
\end{lstlisting}

The entire system can be started with:
\begin{lstlisting}
docker compose up -d
\end{lstlisting}

The frontend is then reachable at \texttt{http://localhost:5173}.  
A persistent WebSocket connection is used alongside REST APIs to support real-time updates across clients.

\subsection{Backend Implementation}

The backend follows a layered Spring Boot structure. Controllers expose REST endpoints, Services implement poll, 
vote, and comment logic, and Repositories handle persistence via JPA or an in-memory store. Redis is used as a 
simple cache for frequently read poll results.

\subsubsection{Authentication and Security}

Authentication is implemented with stateless JWT tokens. Viewing polls and voting are public operations, 
while creating polls and comments requires authentication. The security rules are configured as:

\begin{lstlisting}[language=Java]
// SecurityConfig (selected rules)
http.csrf(AbstractHttpConfigurer::disable)
  .sessionManagement(s -> s.sessionCreationPolicy(STATELESS))
  .authorizeHttpRequests(a -> a
    .requestMatchers("/api/auth/**", "/rawws").permitAll()
    .requestMatchers(HttpMethod.GET, "/api/polls/**").permitAll()
    .requestMatchers(HttpMethod.POST, "/api/polls/*/vote").permitAll()
    .anyRequest().authenticated());
\end{lstlisting}

The \texttt{JwtAuthFilter} validates tokens on each request and injects the authenticated user into 
controller methods using \texttt{@AuthenticationPrincipal}.  

\subsubsection{Core APIs and Real-Time Updates}

Endpoints under \texttt{/api/polls} handle CRUD operations, comments, and voting. A shortened version of 
the voting endpoint is shown below:

\begin{lstlisting}[language=Java]
// PollController (vote endpoint)
@PostMapping("/{id}/vote")
public boolean castVote(@PathVariable Integer id,
                        @RequestParam Integer presentationOrder,
                        @AuthenticationPrincipal User user) {
  return pollService.castVote(
     id,
     user == null ? Optional.empty() : Optional.of(user.getUserId()),
     presentationOrder);
}
\end{lstlisting}

On each update, the backend broadcasts a minimal WebSocket message to prompt clients to refresh their view:

\begin{lstlisting}[language=Java]
RawWebSocketServer.broadcast("pollsUpdated");
\end{lstlisting}

This keeps the UI synchronized without polling.

\subsubsection{Kafka Integration}

Kafka serves as the event bus for vote and poll updates. Each poll receives a dedicated topic to maintain 
ordering and isolate events.

Publishing events:

\begin{lstlisting}[language=Java]
// ProducerService (send event)
public void sendEvent(String topic, Map<String, Object> data) {
  kafkaTemplate.send(topic, data);
}
\end{lstlisting}

Consuming events:

\begin{lstlisting}[language=Java]
// ConsumerService (pattern subscription)
@KafkaListener(topicPattern="poll.voteChange.*", groupId="poll-app")
public void onVoteChange(Map<String, Object> event) {
  // invalidate Redis cache and notify WebSocket layer
}
\end{lstlisting}


We use PollTopicManager to create Kafka topics dynamically. Whenever a poll is created, 
we also create a topic for that poll's events. 
This makes it easy to group events and scale the system. Here is our implementation below:

\begin{lstlisting}[language=Java]
// PollTopicManager (per-poll topics)
 public void createPollTopic(Integer pollId) {
        String topicName = getTopicNameForPoll(pollId);
        NewTopic topic = new NewTopic(topicName, 1, (short) 3);
        kafkaAdmin.createOrModifyTopics(topic);
        logger.info("Topic created successfully.");
    }
\end{lstlisting}

This approach separates writes from cache invalidation and real-time UI updates, improving system responsiveness 
under load.

\subsection{Frontend Implementation}

The frontend is built in React and TypeScript. REST APIs fetch poll data, while a single WebSocket connection 
delivers push updates. The WebSocket setup is shown below:

\begin{lstlisting}[language=TypeScript]
// ws.ts
export function connectWs() {
  const url = `${location.protocol==="https:"?"wss":"ws"}://${location.hostname}:8080/rawws`;
  const ws = new WebSocket(url);
  ws.onmessage = ev => {
    try { emit(JSON.parse(ev.data)); }
    catch { emit(ev.data); }
  };
}
\end{lstlisting}

Components subscribe to events and handle updates selectively:

\begin{lstlisting}[language=TypeScript]
// App.tsx
useEffect(() => onWs(msg => {
  if (msg === "pollsUpdated") refreshPolls();
  if (msg === "commentsUpdated") bumpCommentsVersion(activePollId);
}), []);
\end{lstlisting}

This pattern keeps the UI responsive with minimal network traffic.

\subsection{Extensibility and Future Work}

The modular architecture allows further development, such as new poll types, sharing features, and improved authentication.  
A mobile client can reuse the existing REST and WebSocket APIs.  
Future improvements include stronger production security settings and persistent database storage.