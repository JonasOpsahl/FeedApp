
% This section should provide brief details of how the prototype has been implemented.
% You may want to use come code snippets here, but only focus on core features and aspects.
% You are not meant to copy/paste your whole application code into the report.
% Focus for instance how other developers may run your application and how they might develop it further...


% The example below shows how you may include code. There are similar
% styles for many other langages - in case you do not use Java in your
% project. You can wrap the listing into a figure in case you need to
% refer to it. How to create a figure was shown in Section~\ref{sec:technology}.

% \lstinputlisting[language=java]{code/BoksVolum.java}

\section{Prototype Implementation}
\label{sec:implementation}

This section summarizes how the FeedApp prototype has been implemented, focusing on the core technical components, the main implementation challenges, and how developers can run or extend the system.



\subsection{Setup and Deployment}
Describe:

\begin{itemize}
	\item Docker Compose setup (frontend, backend, Redis, Kafka),
	\item Environment variables and ports,
	\item Public images on Docker Hub,
    \item Commands for building and running locally
\end{itemize}

Services: Spring Boot backend, React (Vite) frontend, Redis, and Kafka. All run with Docker Compose.

How to run
\begin{itemize}
 \item \texttt{docker compose up -d}
 \item Frontend: \texttt{http://localhost:5173}
 \item Backend: \texttt{http://localhost:8080}
\end{itemize}


Compose
\begin{lstlisting}[language=yaml]
backend:
 ports: ["8080:8080"]
 environment:
   - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:29092
   - SPRING_REDIS_HOST=redis
frontend: { ports: ["5173:5173"], depends_on: [backend] }
\end{lstlisting}


\subsection{Backend Implementation}

Briefly describe:

\begin{itemize}
	\item Spring Boot / Java version,
	\item REST API structure,
	\item PollService architecture (Hibernate, Caching, etc.),
    \item Persistence and messaging (H2, Redis, Kafka),
	\item Security (JWT, authentication flow),
	\item Example of key logic (e.g., cache invalidation or voting process)
\end{itemize}

Layering: Controllers map HTTP to Service methods; Services hold domain logic;
Repositories persist entities.
Small events are pushed to clients over a raw WebSocket to keep UIs in sync.


Controller example (vote)
\begin{lstlisting}[language=Java]
// PollController (excerpt)
@PostMapping("/{id}/vote")
public boolean castVote(@PathVariable Integer id,
                       @RequestParam Integer presentationOrder,
                       @AuthenticationPrincipal User user) {
 return pollService.castVote(id, user == null ? Optional.empty() : Optional.of(user.getUserId()),
                             presentationOrder);
}
\end{lstlisting}


Notify clients after changes
\begin{lstlisting}[language=Java]
// on create/update/delete
RawWebSocketServer.broadcast("pollsUpdated");
\end{lstlisting}



\subsection{Frontend Implementation}

Briefly describe:

\begin{itemize}
	\item React + TypeScript structure,
	\item Main components (CreatePoll, VoteOnPoll, CommentSection, Auth),
	\item Communication with backend (REST + WebSocket),
    \item State management and authentication handling,
	\item Short code snippet illustrating an API call or WebSocket usage
\end{itemize}

The React app fetches data via REST and listens to a single WebSocket for deltas (new polls, comments, votes).


WebSocket client
\begin{lstlisting}[language=TypeScript]
// ws.ts
export const onWs = (f:(e:unknown)=>void) => (listeners.add(f), () => listeners.delete(f));
export function connectWs() {
 const u = `${location.protocol==="https:"?"wss":"ws"}://${location.hostname}:8080/rawws`;
 const ws = new WebSocket(u);
 ws.onmessage = ev => { try { emit(JSON.parse(ev.data)); } catch { emit(ev.data); } };
}
\end{lstlisting}


Integrating updates (App)
\begin{lstlisting}[language=TypeScript]
// App.tsx
useEffect(() => onWs(m => {
 if (m === "pollsUpdated") refreshPolls();
 if (m === "commentsUpdated") bumpCommentsVersion(activePollId);
}), []);
\end{lstlisting}


Calling the API (vote)
\begin{lstlisting}[language=TypeScript]
await fetch(`/api/polls/${id}/vote?presentationOrder=${order}`, { method: "POST" });
\end{lstlisting}


\subsection{Security}
Stateless JWT protects write operations; selected GET routes are public; CORS allows localhost during development.


\begin{lstlisting}[language=Java]
// SecurityConfig (rules excerpt)
http.csrf(AbstractHttpConfigurer::disable)
   .sessionManagement(s -> s.sessionCreationPolicy(STATELESS))
   .authorizeHttpRequests(a -> a
     .requestMatchers("/api/auth/**", "/rawws").permitAll()
     .requestMatchers(HttpMethod.GET, "/api/polls/**").permitAll()
     .requestMatchers(HttpMethod.POST, "/api/polls/*/vote").permitAll()
     .anyRequest().authenticated());
\end{lstlisting}


\subsection{Extensibility and Future Work}
...