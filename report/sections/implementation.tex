\section{Prototype Implementation}
\label{sec:implementation}

This section gives a short view of how the prototype works: how to run it, how the backend processes changes, 
how events reach clients, and what can be extended. 

\subsection{Setup and Deployment}
FeedApp runs under Docker Compose (Spring Boot backend, React/Vite frontend, Redis cache, Kafka cluster). 
Core backend settings are passed as environment variables:
\begin{lstlisting}[language=yaml]
backend:
  image: erlendandre/feedapp-backend:latest
  ports: ["8080:8080"]
  environment:
    - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka-1:29092,kafka-2:29092,kafka-3:29092
    - SPRING_REDIS_HOST=redis
frontend:
  image: erlendandre/feedapp-frontend:latest
  ports: ["5173:5173"]
\end{lstlisting}
Start everything with:\vspace{-0.3em}
\begin{lstlisting}
docker compose up -d
\end{lstlisting}
The UI is hosted at \texttt{http://localhost:5173}. A single WebSocket complements REST for real-time updates.

\subsection{Backend}
The Spring Boot backend exposes REST endpoints (polls, votes, comments) via controllers; services hold logic; 
repositories use JPA or an in-memory profile. Redis caches popular poll results. Stateless JWT security allows 
public viewing and voting while protecting creation actions:
\begin{lstlisting}[language=Java]
// Security rules (excerpt)
authorizeHttpRequests(a -> a
  .requestMatchers("/api/auth/**", "/rawws").permitAll()
  .requestMatchers(HttpMethod.GET, "/api/polls/**").permitAll()
  .requestMatchers(HttpMethod.POST, "/api/polls/*/vote").permitAll()
  .anyRequest().authenticated());
\end{lstlisting}
After each change, the server sends a WebSocket message  trigger targeted data reloads:
\begin{lstlisting}[language=Java]
RawWebSocketServer.broadcast("pollsUpdated");
\end{lstlisting}

\subsubsection*{Kafka Integration}
Every poll gets its own topic (\texttt{poll.voteChange.<id>}) to keep ordering local and isolate events. 
Producer and consumer are simple helpers:
\begin{lstlisting}[language=Java]
// Producer for sendng events
kafkaTemplate.send(topicName, data);
// Consumer for reacting to events
@KafkaListener(topicPattern="poll.voteChange.*", groupId="poll-app")
public void onVoteChange(Map<String,Object> e) { /* invalidate cache + notify */ }
\end{lstlisting}
Each topic uses a single partition and is copied to three brokers, so messages stay in order and survive a node failure.

\subsection{Frontend}
The React + TypeScript frontend fetches state over REST and listens on one WebSocket connection:
\begin{lstlisting}[language=TypeScript]
const ws = new WebSocket(`${location.protocol==="https:"?"wss":"ws"}://${location.hostname}:8080/rawws`);
ws.onmessage = ev => emit(safeParse(ev.data));
\end{lstlisting}
Selective refresh logic keeps traffic low:
\begin{lstlisting}[language=TypeScript]
onWs(msg => {
  if (msg === "pollsUpdated") refreshPolls();
  if (msg === "commentsUpdated") bumpCommentsVersion(activePollId);
});
\end{lstlisting}

\subsection{Extensibility}
The modular design supports new poll types, friend/sharing features, stronger authentication, 
and mobile clients reusing REST/WebSocket APIs. We were thinking about making a larger external benchmark results, but due to
limited time-constraints we were not able to create them.
